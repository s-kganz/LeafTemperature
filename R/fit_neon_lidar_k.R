# To run the radiation submodel, we need empirical light attenutation
# coefficients for direct and diffuse radiation. These are calculated empirically
# based on observations where diffuse and direct light dominate. We also need
# to map vertical heights above ground to cumulative leaf area index. This
# script calculates the attenuation coefficients and generates LAI-Z crosswalk
# tables.

# For each PAR observation we need to know the following:
# - What height was it measured at?
# - What was the PPFD value for this observation?
# - What was the TOC shortwave flux?
# - What proportion of incoming shortwave was diffuse?
# cat("Preparing PAR attenuation data...")


# Fit LiDAR attenuation constants ----
fit_lidar_constants <- function(site, site_lai, tower_toc_rad, lidar_dir, 
                                zmax=NA, zmin=1) {
  # Z where cumulative LAI == total LAI and measurement height of Io
  if (is.na(zmax)) {
    zmax <- tower_toc_rad %>% filter(SITE_NEON == site) %>% 
      pull(ppfd_z) %>% max() %>% ceiling()
  }
  
  las <- lidR::readLAS(file.path(
    lidar_dir, str_c(site, ".laz")
  )) %>%
    lidR::filter_poi(Z > zmin, Z < zmax)
  
  # Calibrate k so that the integral of LAD == LAI. 
  lad_uncal_sum <- lidR::LAD(las$Z, k=1, z0 = zmin) %>% pull(lad) %>% sum(na.rm=TRUE)
  k_lai <- lad_uncal_sum / site_lai
  
  lad_profile <- lidR::LAD(las$Z, k=k_lai, z0 = zmin)
  # Reverse the order of rows so we can compute the cumulative LAI looking 
  # *down* the canopy.
  lad_profile <- lad_profile[nrow(lad_profile):1, ]
  lad_profile$cum_lai <- cumsum(lad_profile$lad)
  
  # Now calculate transmission profile through the canopy under direct and
  # diffuse conditions. For each z, calc geometric mean transmittance to that 
  # point in the canopy.
  this_tower_toc_rad <- tower_toc_rad %>% filter(SITE_NEON == site)
  
  iv_io_df <- this_tower_toc_rad %>%
    mutate(iv = ppfd_value,
           io = PPFD_IN_TOC,
           proportion_diffuse_bin = round(proportion_diffuse, digits=1)) %>%
    mutate(iv_io = iv / io) %>%
    group_by(ppfd_z, proportion_diffuse_bin) %>%
    summarize(
      iv_io_mean = suppressWarnings(log(iv_io)) %>% median(na.rm=TRUE) %>% exp(),
      # https://en.wikipedia.org/wiki/Geometric_standard_deviation
      iv_io_sd = suppressWarnings(log(iv_io / iv_io_mean)^2) %>% 
        mean(na.rm=TRUE) %>% sqrt() %>% exp()
    ) %>%
    drop_na() %>%
    mutate(cum_lai = approx(lad_profile$z, lad_profile$cum_lai, ppfd_z, rule=2)$y,
           site = site)
  
  # Force the y-intercept at log(iv_io) = 0
  iv_io_lm <- lm(
    log(iv_io_mean) ~ cum_lai + cum_lai:proportion_diffuse_bin + 0, 
    data=iv_io_df
  )
  
  return(list(
    site=site,
    lad_profile=lad_profile,
    iv_io_data=iv_io_df,
    rad_coef=coef(iv_io_lm),
    lai_coef=k_lai
  ))
}

#' Fit empirical light attenuation coefficients to aerial LiDAR
#'
#' @param site_meta Site metadata table \code{\link{site_meta}}.
#' @param site_lai Site leaf area index table \code{\link{manual_lai}}
#' @param tower_dir Directory containing tower data files generated by [get_amf_tower_data()].
#' @param lidar_dir Directory containing aerial LiDAR clouds generated by [get_neon_lidar()]
#' @param outdir Directory where output tables will be written.
#'
#' @description
#' To run the radiation submodel, we need empirical light attenutation coefficients for direct and diffuse radiation. These are calculated empirically based on observations where diffuse and direct light dominate. We also need to map vertical heights above ground to cumulative leaf area index. This script calculates the attenuation coefficients and generates LAI-Z crosswalk tables.
#' 
#'
#' @export
#'
fit_neon_lidar_k <- function(site_meta, site_lai, tower_dir, lidar_dir, outdir) {
  # Prepare site-level LAIs ----
  # If there is a prior estimate of LAI in the literature, use it. Otherwise,
  # use the DHP-derived estimate.
  site_meta <- site_meta %>%
    left_join(site_lai, by=c("site_neon"="site")) %>%
    mutate(
      lai_best = ifelse(is.na(lai), L_dhp_corrected, lai)
    )
  
  # Prepare light attenuation data ----
  tower_files <- list.files(tower_dir, pattern="*.csv",
                            full.names=TRUE)
  
  measure_heights <- amf_var_heights()
  
  tower_toc_rad <- lapply(tower_files, function(file) {
    # Extract site information from filename
    site_amf <- str_remove(basename(file), ".csv")
    site_neon <- site_meta$site_neon[match(site_amf, site_meta$site_ameriflux)]
    cat("\t", site_neon, "\n")
    
    # Open tower observations
    this_tower <- read_csv(file, col_types=cols())
    
    # Get measurement heights for this tower
    this_heights <- measure_heights %>% filter(Site_ID == site_amf)
    sw_vars <- grep("SW_IN_1_1_\\d", names(this_tower), value=TRUE)
    ppfd_vars <- grep("PPFD_IN_\\d_\\d_\\d", names(this_tower), value=TRUE)
    ppfd_z <- this_heights %>%
      filter(Variable %in% ppfd_vars) %>% 
      select(Variable, Height)
    
    
    this_tower %>%
      mutate(
        # Attach site information for later
        SITE_NEON = site_neon,
        # Compute top of canopy values
        SW_IN_TOC = rowMeans(this_tower %>% select(all_of(sw_vars)), 
                             na.rm=TRUE),
        PPFD_IN_TOC = PPFD_IN_1_1_1,
        proportion_diffuse = SW_DIF / SW_IN_TOC,
        proportion_diffuse = pmin(pmax(proportion_diffuse, 0), 1)
      ) %>%
      # Drop observations without TOC values and values at night
      filter(!is.nan(SW_IN_TOC), !is.na(PPFD_IN_TOC), SW_IN_TOC > 100) %>%
      # Drop unnecessary columns
      select(SITE_NEON, PPFD_IN_TOC, proportion_diffuse, 
             all_of(ppfd_vars)) %>%
      # Pivot PAR observations to join in measurement heights
      pivot_longer(all_of(ppfd_vars), 
                   names_to = "ppfd_variable", values_to="ppfd_value") %>%
      left_join(ppfd_z, by=c("ppfd_variable"="Variable")) %>%
      # Cleanup
      rename(ppfd_z = Height) %>%
      filter(!is.na(ppfd_value))
    
  }) %>% bind_rows()
  
  lidar_constants <- lapply(
    1:nrow(site_meta),
    function(i) {
      fit_lidar_constants(
        site=site_meta$site_neon[i],
        site_lai=site_meta$lai_best[i],
        tower_toc_rad=tower_toc_rad,
        lidar_dir=lidar_dir,
        zmax=site_meta$canopy_height[i],
        zmin=1
      )
    }
  )
  
  # Extract results ----
  
  # LAD profiles
  lad_data <- lapply(lidar_constants, function(l) {
    l$lad_profile %>% mutate(site = l$site)
  }) %>% bind_rows()
  
  # Light attenuation data
  iv_io_data <- lapply(lidar_constants, function(l) l$iv_io_data) %>% bind_rows()
  
  # Attenuation constants
  lidar_constants_df <- lapply(lidar_constants, function(l) {
    list(
      site=l$site,
      lai_coef=l$lai_coef,
      # Force attenuation coefficients less than 0
      kb_real=min(unname(l$rad_coef[1]), 0),
      kd_real=min(unname(l$rad_coef[1] + l$rad_coef[2]), 0)
    )
  }) %>% bind_rows()
  
  write_if_not_exist(lidar_constants_df, file.path(outdir, "neon_lidar_constants.csv"))
  write_if_not_exist(iv_io_data, file.path(outdir, "neon_lidar_transmission_data.csv"))
  lad_data %>%
    drop_na() %>%
    write_if_not_exist(file.path(outdir, "neon_lad_profiles.csv"))
}
